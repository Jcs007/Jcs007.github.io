<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | My Octopress Blog]]></title>
  <link href="http://jcs007.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://jcs007.github.io/"/>
  <updated>2017-09-30T21:24:58+08:00</updated>
  <id>http://jcs007.github.io/</id>
  <author>
    <name><![CDATA[Jcs007]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Demo10]]></title>
    <link href="http://jcs007.github.io/blog/2017/09/12/demo10/"/>
    <updated>2017-09-12T17:11:15+08:00</updated>
    <id>http://jcs007.github.io/blog/2017/09/12/demo10</id>
    <content type="html"><![CDATA[<h1>DOM</h1>

<h3>使用write()和writeIn()方法动态的包含外部资源，例如javascript文件等，必须注意不能像下面的例子直接包含字符串“</script>”。这样会导致该字符串被解释为脚本块的结束，它后面的代码将无法执行。</h3>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;document.write()&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script type="text/javascript"&gt;
        document.write("&lt;script type=\"text/javascript\" src=\"file.js\"&gt;"+"&lt;/script&gt;");
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>字符串"</script>&ldquo;将被解释为与外部的<script>标签匹配，结果文本&rdquo;);将会出现在页面中。为了避免这个问题，在字符串"</script>&ldquo;中加入转义字符\即可。</h3>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;document.write()&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script type="text/javascript"&gt;
        document.write("&lt;script type=\"text/javascript\" src=\"file.js\"&gt;"+"&lt;\/script&gt;");
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React]]></title>
    <link href="http://jcs007.github.io/blog/2017/08/19/demo08/"/>
    <updated>2017-08-19T00:01:36+08:00</updated>
    <id>http://jcs007.github.io/blog/2017/08/19/demo08</id>
    <content type="html"><![CDATA[<h1>React入门</h1>

<ul>
<li>使用React的网页源码，结构如下。</li>
</ul>


<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src="react.js"&gt;&lt;/script&gt;
    &lt;script src="react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="browser.min.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;
    &lt;script type="text/babel"&gt;
      // ** Our code goes here! **
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<ul>
<li>ReactDOM.render是React的最基本的方法，用于将模版转为HTML语言，并插入指定的DOM节点。</li>
</ul>


<pre><code>ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.getElementById('example')
);
</code></pre>

<ul>
<li>JSX语法</li>
</ul>


<pre><code>var names = ['Alice', 'Emily', 'Kate'];

ReactDOM.render(
  &lt;div&gt;
  {
    names.map(function (name) {
      return &lt;div&gt;Hello, {name}!&lt;/div&gt;
    })
  }
  &lt;/div&gt;,
  document.getElementById('example')
);
</code></pre>

<ul>
<li>组件</li>
</ul>


<pre><code>var HelloMessage = React.createClass({
  render: function() {
    return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
  }
});

ReactDOM.render(
  &lt;HelloMessage name="John" /&gt;,
  document.getElementById('example')
);
</code></pre>

<ul>
<li>this.props.children</li>
</ul>


<pre><code>var NotesList = React.createClass({
  render: function() {
    return (
      &lt;ol&gt;
      {
        React.Children.map(this.props.children, function (child) {
          return &lt;li&gt;{child}&lt;/li&gt;;
        })
      }
      &lt;/ol&gt;
    );
  }
});

ReactDOM.render(
  &lt;NotesList&gt;
    &lt;span&gt;hello&lt;/span&gt;
    &lt;span&gt;world&lt;/span&gt;
  &lt;/NotesList&gt;,
  document.body
);
</code></pre>

<ul>
<li>PropTypes</li>
</ul>


<pre><code>var MyTitle = React.createClass({
  propTypes: {
    title: React.PropTypes.string.isRequired,
  },

  render: function() {
     return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
   }
});
var data = 123;

ReactDOM.render(
  &lt;MyTitle title={data} /&gt;,
  document.body
);
</code></pre>

<ul>
<li>getDefaultProps方法可以用来设置组件属性的默认值。</li>
</ul>


<pre><code>var MyTitle = React.createClass({
  getDefaultProps : function () {
    return {
      title : 'Hello World'
    };
  },

  render: function() {
     return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
   }
});

ReactDOM.render(
  &lt;MyTitle /&gt;,
  document.body
);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event Handler]]></title>
    <link href="http://jcs007.github.io/blog/2017/08/11/demo06/"/>
    <updated>2017-08-11T23:16:35+08:00</updated>
    <id>http://jcs007.github.io/blog/2017/08/11/demo06</id>
    <content type="html"><![CDATA[<h1>事件处理程序</h1>

<ul>
<li><p>HTML事件处理程序</p>

<ul>
<li>缺点：HTML和JavaScript代码的耦合性太高，更换事件处理程序，就要改动两个地方，不可以增加多事件。</li>
</ul>
</li>
<li><p>DOM0事件处理程序</p>

<ul>
<li>局限：只能绑定一个事件，后面的事件会覆盖前面的事件。</li>
</ul>
</li>
<li><p>DOM2事件处理程序</p>

<ul>
<li>addEventListener(事件名，函数，布尔值）false：冒泡；true：捕获。</li>
<li>removeEventListener(事件名，函数，布尔值）false：冒泡；true：捕获。</li>
<li>主要优点：可以添加多个事件处理程序。</li>
<li>支持程度：IE9，Firefox，safari，chrome，opera。</li>
</ul>
</li>
<li><p>IE事件处理程序</p>

<ul>
<li>attachEvent(事件名，函数）</li>
<li>detachEvent(事件名，函数）</li>
<li>只支持事件冒泡。支持IE，opera。</li>
</ul>
</li>
<li><p>跨浏览器事件处理程序</p></li>
</ul>


<pre><code>var x=document.getElementById('btn1')
function addApp(){
    if(x.addEventListener){
        x.addEventListener("click",clickMe,false);
    }else if(x.attachEvent){
        x.attachEvent("click",clickMe);
    }else{
        x.onclick=clickMe;
    }
}
function clickMe(){
    alert("点击到我了！");
}
</code></pre>
]]></content>
  </entry>
  
</feed>
